// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sign.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type HashAlgo int32

const (
	HashAlgo_Unspecified_Hash HashAlgo = 0
	HashAlgo_SHA224           HashAlgo = 1
	HashAlgo_SHA256           HashAlgo = 2
	HashAlgo_SHA384           HashAlgo = 3
	HashAlgo_SHA512           HashAlgo = 4
)

var HashAlgo_name = map[int32]string{
	0: "Unspecified_Hash",
	1: "SHA224",
	2: "SHA256",
	3: "SHA384",
	4: "SHA512",
}

var HashAlgo_value = map[string]int32{
	"Unspecified_Hash": 0,
	"SHA224":           1,
	"SHA256":           2,
	"SHA384":           3,
	"SHA512":           4,
}

func (x HashAlgo) String() string {
	return proto.EnumName(HashAlgo_name, int32(x))
}

func (HashAlgo) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{0}
}

// KeyMeta identifies the private key used in crypto operations.
type KeyMeta struct {
	// The id of the key that will be used in crypto operations.
	Identifier           string   `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyMeta) Reset()         { *m = KeyMeta{} }
func (m *KeyMeta) String() string { return proto.CompactTextString(m) }
func (*KeyMeta) ProtoMessage()    {}
func (*KeyMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{0}
}

func (m *KeyMeta) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyMeta.Unmarshal(m, b)
}
func (m *KeyMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyMeta.Marshal(b, m, deterministic)
}
func (m *KeyMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyMeta.Merge(m, src)
}
func (m *KeyMeta) XXX_Size() int {
	return xxx_messageInfo_KeyMeta.Size(m)
}
func (m *KeyMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyMeta.DiscardUnknown(m)
}

var xxx_messageInfo_KeyMeta proto.InternalMessageInfo

func (m *KeyMeta) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

// KeyMetas contains a list of KeyMetas.
type KeyMetas struct {
	Keys                 []*KeyMeta `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *KeyMetas) Reset()         { *m = KeyMetas{} }
func (m *KeyMetas) String() string { return proto.CompactTextString(m) }
func (*KeyMetas) ProtoMessage()    {}
func (*KeyMetas) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{1}
}

func (m *KeyMetas) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyMetas.Unmarshal(m, b)
}
func (m *KeyMetas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyMetas.Marshal(b, m, deterministic)
}
func (m *KeyMetas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyMetas.Merge(m, src)
}
func (m *KeyMetas) XXX_Size() int {
	return xxx_messageInfo_KeyMetas.Size(m)
}
func (m *KeyMetas) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyMetas.DiscardUnknown(m)
}

var xxx_messageInfo_KeyMetas proto.InternalMessageInfo

func (m *KeyMetas) GetKeys() []*KeyMeta {
	if m != nil {
		return m.Keys
	}
	return nil
}

// SSHCertificateSigningRequest specifies the info used for signing an SSH certificate.
type SSHCertificateSigningRequest struct {
	// Identifies the signing key in the HSM used for signing the certificate.
	KeyMeta *KeyMeta `protobuf:"bytes,1,opt,name=key_meta,json=keyMeta,proto3" json:"key_meta,omitempty"`
	// List of usernames or hostnames in the Principals field.
	Principals []string `protobuf:"bytes,2,rep,name=principals,proto3" json:"principals,omitempty"`
	// SSH public key.
	PublicKey string `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Validity period of the certificate in seconds.
	Validity uint64 `protobuf:"varint,4,opt,name=validity,proto3" json:"validity,omitempty"`
	// Key ID in the certificate.
	KeyId string `protobuf:"bytes,5,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Critical Options field in the certificate.
	CriticalOptions map[string]string `protobuf:"bytes,6,rep,name=critical_options,json=criticalOptions,proto3" json:"critical_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Extensions field in the certificate.
	Extensions           map[string]string `protobuf:"bytes,7,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SSHCertificateSigningRequest) Reset()         { *m = SSHCertificateSigningRequest{} }
func (m *SSHCertificateSigningRequest) String() string { return proto.CompactTextString(m) }
func (*SSHCertificateSigningRequest) ProtoMessage()    {}
func (*SSHCertificateSigningRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{2}
}

func (m *SSHCertificateSigningRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SSHCertificateSigningRequest.Unmarshal(m, b)
}
func (m *SSHCertificateSigningRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SSHCertificateSigningRequest.Marshal(b, m, deterministic)
}
func (m *SSHCertificateSigningRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSHCertificateSigningRequest.Merge(m, src)
}
func (m *SSHCertificateSigningRequest) XXX_Size() int {
	return xxx_messageInfo_SSHCertificateSigningRequest.Size(m)
}
func (m *SSHCertificateSigningRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SSHCertificateSigningRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SSHCertificateSigningRequest proto.InternalMessageInfo

func (m *SSHCertificateSigningRequest) GetKeyMeta() *KeyMeta {
	if m != nil {
		return m.KeyMeta
	}
	return nil
}

func (m *SSHCertificateSigningRequest) GetPrincipals() []string {
	if m != nil {
		return m.Principals
	}
	return nil
}

func (m *SSHCertificateSigningRequest) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *SSHCertificateSigningRequest) GetValidity() uint64 {
	if m != nil {
		return m.Validity
	}
	return 0
}

func (m *SSHCertificateSigningRequest) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *SSHCertificateSigningRequest) GetCriticalOptions() map[string]string {
	if m != nil {
		return m.CriticalOptions
	}
	return nil
}

func (m *SSHCertificateSigningRequest) GetExtensions() map[string]string {
	if m != nil {
		return m.Extensions
	}
	return nil
}

// SSHKey specifies an SSH key that can either be an:
// 1. SSH public key, or
// 2. SSH user/host certificate
type SSHKey struct {
	// The encoded string of the SSH key.
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSHKey) Reset()         { *m = SSHKey{} }
func (m *SSHKey) String() string { return proto.CompactTextString(m) }
func (*SSHKey) ProtoMessage()    {}
func (*SSHKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{3}
}

func (m *SSHKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SSHKey.Unmarshal(m, b)
}
func (m *SSHKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SSHKey.Marshal(b, m, deterministic)
}
func (m *SSHKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSHKey.Merge(m, src)
}
func (m *SSHKey) XXX_Size() int {
	return xxx_messageInfo_SSHKey.Size(m)
}
func (m *SSHKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SSHKey.DiscardUnknown(m)
}

var xxx_messageInfo_SSHKey proto.InternalMessageInfo

func (m *SSHKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// X509CertificateSigningRequest specifies the info used for signing an X509 certificate.
type X509CertificateSigningRequest struct {
	// Identifies the signing key in the HSM used for signing the certificate.
	KeyMeta *KeyMeta `protobuf:"bytes,1,opt,name=key_meta,json=keyMeta,proto3" json:"key_meta,omitempty"`
	// X509 certificate signing request encoded in PEM format.
	Csr string `protobuf:"bytes,2,opt,name=csr,proto3" json:"csr,omitempty"`
	// Validity period of the certificate in seconds.
	Validity uint64 `protobuf:"varint,3,opt,name=validity,proto3" json:"validity,omitempty"`
	// X509 certificate ExtKeyUsage.
	// https://godoc.org/crypto/x509#ExtKeyUsage
	ExtKeyUsage          []int32  `protobuf:"varint,4,rep,packed,name=ext_key_usage,json=extKeyUsage,proto3" json:"ext_key_usage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *X509CertificateSigningRequest) Reset()         { *m = X509CertificateSigningRequest{} }
func (m *X509CertificateSigningRequest) String() string { return proto.CompactTextString(m) }
func (*X509CertificateSigningRequest) ProtoMessage()    {}
func (*X509CertificateSigningRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{4}
}

func (m *X509CertificateSigningRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_X509CertificateSigningRequest.Unmarshal(m, b)
}
func (m *X509CertificateSigningRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_X509CertificateSigningRequest.Marshal(b, m, deterministic)
}
func (m *X509CertificateSigningRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509CertificateSigningRequest.Merge(m, src)
}
func (m *X509CertificateSigningRequest) XXX_Size() int {
	return xxx_messageInfo_X509CertificateSigningRequest.Size(m)
}
func (m *X509CertificateSigningRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_X509CertificateSigningRequest.DiscardUnknown(m)
}

var xxx_messageInfo_X509CertificateSigningRequest proto.InternalMessageInfo

func (m *X509CertificateSigningRequest) GetKeyMeta() *KeyMeta {
	if m != nil {
		return m.KeyMeta
	}
	return nil
}

func (m *X509CertificateSigningRequest) GetCsr() string {
	if m != nil {
		return m.Csr
	}
	return ""
}

func (m *X509CertificateSigningRequest) GetValidity() uint64 {
	if m != nil {
		return m.Validity
	}
	return 0
}

func (m *X509CertificateSigningRequest) GetExtKeyUsage() []int32 {
	if m != nil {
		return m.ExtKeyUsage
	}
	return nil
}

// X509Certificate specifies an X509 certificate.
type X509Certificate struct {
	// The X509 certificate encoded in PEM format.
	Cert                 string   `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *X509Certificate) Reset()         { *m = X509Certificate{} }
func (m *X509Certificate) String() string { return proto.CompactTextString(m) }
func (*X509Certificate) ProtoMessage()    {}
func (*X509Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{5}
}

func (m *X509Certificate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_X509Certificate.Unmarshal(m, b)
}
func (m *X509Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_X509Certificate.Marshal(b, m, deterministic)
}
func (m *X509Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509Certificate.Merge(m, src)
}
func (m *X509Certificate) XXX_Size() int {
	return xxx_messageInfo_X509Certificate.Size(m)
}
func (m *X509Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_X509Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_X509Certificate proto.InternalMessageInfo

func (m *X509Certificate) GetCert() string {
	if m != nil {
		return m.Cert
	}
	return ""
}

// PublicKey is a encoded string of the public key specified by users.
type PublicKey struct {
	// The encoded string of the public key.
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{6}
}

func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublicKey.Unmarshal(m, b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return xxx_messageInfo_PublicKey.Size(m)
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type BlobSigningRequest struct {
	// Identifies the signing key in the PKCS#11 device used for signing the blob.
	KeyMeta *KeyMeta `protobuf:"bytes,1,opt,name=key_meta,json=keyMeta,proto3" json:"key_meta,omitempty"`
	// the hash digest of blob in base64 which will be signed.
	Digest string `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
	// the algorithm of hash function used to generate the digest
	// https://golang.org/pkg/crypto/#Hash.
	HashAlgorithm        HashAlgo `protobuf:"varint,3,opt,name=hash_algorithm,json=hashAlgorithm,proto3,enum=v3.HashAlgo" json:"hash_algorithm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobSigningRequest) Reset()         { *m = BlobSigningRequest{} }
func (m *BlobSigningRequest) String() string { return proto.CompactTextString(m) }
func (*BlobSigningRequest) ProtoMessage()    {}
func (*BlobSigningRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{7}
}

func (m *BlobSigningRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlobSigningRequest.Unmarshal(m, b)
}
func (m *BlobSigningRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlobSigningRequest.Marshal(b, m, deterministic)
}
func (m *BlobSigningRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobSigningRequest.Merge(m, src)
}
func (m *BlobSigningRequest) XXX_Size() int {
	return xxx_messageInfo_BlobSigningRequest.Size(m)
}
func (m *BlobSigningRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobSigningRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobSigningRequest proto.InternalMessageInfo

func (m *BlobSigningRequest) GetKeyMeta() *KeyMeta {
	if m != nil {
		return m.KeyMeta
	}
	return nil
}

func (m *BlobSigningRequest) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

func (m *BlobSigningRequest) GetHashAlgorithm() HashAlgo {
	if m != nil {
		return m.HashAlgorithm
	}
	return HashAlgo_Unspecified_Hash
}

// Signature is a base64 encoded result of signing a blob.
type Signature struct {
	Signature            string   `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_3feb3e12a3dc7fb1, []int{8}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func init() {
	proto.RegisterEnum("v3.HashAlgo", HashAlgo_name, HashAlgo_value)
	proto.RegisterType((*KeyMeta)(nil), "v3.KeyMeta")
	proto.RegisterType((*KeyMetas)(nil), "v3.KeyMetas")
	proto.RegisterType((*SSHCertificateSigningRequest)(nil), "v3.SSHCertificateSigningRequest")
	proto.RegisterMapType((map[string]string)(nil), "v3.SSHCertificateSigningRequest.CriticalOptionsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v3.SSHCertificateSigningRequest.ExtensionsEntry")
	proto.RegisterType((*SSHKey)(nil), "v3.SSHKey")
	proto.RegisterType((*X509CertificateSigningRequest)(nil), "v3.X509CertificateSigningRequest")
	proto.RegisterType((*X509Certificate)(nil), "v3.X509Certificate")
	proto.RegisterType((*PublicKey)(nil), "v3.PublicKey")
	proto.RegisterType((*BlobSigningRequest)(nil), "v3.BlobSigningRequest")
	proto.RegisterType((*Signature)(nil), "v3.Signature")
}

func init() { proto.RegisterFile("sign.proto", fileDescriptor_3feb3e12a3dc7fb1) }

var fileDescriptor_3feb3e12a3dc7fb1 = []byte{
	// 926 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0x5d, 0x6f, 0xe3, 0x44,
	0x14, 0xc5, 0x71, 0x3e, 0x9a, 0xdb, 0x76, 0xeb, 0x9d, 0x96, 0xc8, 0x78, 0xdb, 0x6e, 0x18, 0xb4,
	0xdd, 0x76, 0x3f, 0xe2, 0x6e, 0xb2, 0x81, 0xdd, 0x45, 0x3c, 0xb4, 0xab, 0xaa, 0x41, 0x11, 0xa2,
	0x4a, 0x54, 0x81, 0x78, 0x20, 0x38, 0xce, 0xac, 0x33, 0x8a, 0x6b, 0x07, 0xcf, 0x24, 0xaa, 0x85,
	0x78, 0x01, 0x09, 0x89, 0x67, 0x9e, 0xf8, 0x5d, 0xfc, 0x02, 0x24, 0xde, 0xf9, 0x0b, 0x68, 0xc6,
	0x76, 0x12, 0xe7, 0xa3, 0x2b, 0xb6, 0xf0, 0xd4, 0x7b, 0xef, 0xf8, 0x9e, 0x73, 0xee, 0x99, 0xe9,
	0x0d, 0x00, 0xa3, 0x8e, 0x57, 0x19, 0x06, 0x3e, 0xf7, 0x51, 0x66, 0x5c, 0x33, 0x76, 0x1d, 0xdf,
	0x77, 0x5c, 0x62, 0x5a, 0x43, 0x6a, 0x5a, 0x9e, 0xe7, 0x73, 0x8b, 0x53, 0xdf, 0x63, 0xd1, 0x17,
	0xc6, 0xbd, 0xf8, 0x54, 0x66, 0xdd, 0xd1, 0x1b, 0x93, 0x5c, 0x0d, 0x79, 0x18, 0x1d, 0xe2, 0x23,
	0x28, 0x34, 0x49, 0xf8, 0x05, 0xe1, 0x16, 0xda, 0x07, 0xa0, 0x3d, 0xe2, 0x71, 0xfa, 0x86, 0x92,
	0x40, 0x57, 0xca, 0xca, 0x61, 0xb1, 0x35, 0x53, 0xc1, 0x8f, 0x61, 0x2d, 0xfe, 0x94, 0xa1, 0xfb,
	0x90, 0x1d, 0x90, 0x90, 0xe9, 0x4a, 0x59, 0x3d, 0x5c, 0xaf, 0xae, 0x57, 0xc6, 0xb5, 0x4a, 0x7c,
	0xd6, 0x92, 0x07, 0xf8, 0x6f, 0x15, 0x76, 0xdb, 0xed, 0xc6, 0x6b, 0x12, 0x88, 0x6e, 0xdb, 0xe2,
	0xa4, 0x4d, 0x1d, 0x8f, 0x7a, 0x4e, 0x8b, 0x7c, 0x3f, 0x22, 0x8c, 0xa3, 0x03, 0x58, 0x1b, 0x90,
	0xb0, 0x73, 0x45, 0xb8, 0x25, 0xb9, 0xe6, 0x50, 0x0a, 0x83, 0xa9, 0xaa, 0x61, 0x40, 0x3d, 0x9b,
	0x0e, 0x2d, 0x97, 0xe9, 0x99, 0xb2, 0x2a, 0x54, 0x4d, 0x2b, 0x68, 0x0f, 0x60, 0x38, 0xea, 0xba,
	0xd4, 0xee, 0x0c, 0x48, 0xa8, 0xab, 0x52, 0x75, 0x31, 0xaa, 0x34, 0x49, 0x88, 0x0c, 0x58, 0x1b,
	0x5b, 0x2e, 0xed, 0x51, 0x1e, 0xea, 0xd9, 0xb2, 0x72, 0x98, 0x6d, 0x4d, 0x72, 0xf4, 0x3e, 0xe4,
	0x85, 0x04, 0xda, 0xd3, 0x73, 0xb2, 0x2d, 0x37, 0x20, 0xe1, 0xe7, 0x3d, 0xf4, 0x1d, 0x68, 0x76,
	0x40, 0x39, 0xb5, 0x2d, 0xb7, 0xe3, 0x0f, 0xa5, 0x93, 0x7a, 0x5e, 0xce, 0x59, 0x17, 0x0a, 0x6f,
	0x9a, 0xaa, 0xf2, 0x3a, 0x6e, 0xfc, 0x32, 0xea, 0x3b, 0xf3, 0x78, 0x10, 0xb6, 0xb6, 0xec, 0x74,
	0x15, 0x5d, 0x00, 0x90, 0x6b, 0x4e, 0x3c, 0x26, 0xb1, 0x0b, 0x12, 0xfb, 0xf8, 0xad, 0xd8, 0x67,
	0x93, 0x96, 0x08, 0x76, 0x06, 0xc3, 0x38, 0x85, 0x9d, 0x65, 0xd4, 0x48, 0x03, 0x55, 0xd8, 0x12,
	0x5d, 0xa6, 0x08, 0xd1, 0x0e, 0xe4, 0xc6, 0x96, 0x3b, 0x22, 0x7a, 0x26, 0x9a, 0x59, 0x26, 0xaf,
	0x32, 0x2f, 0x14, 0xe3, 0x33, 0xd8, 0x9a, 0xa3, 0xf8, 0x37, 0xed, 0xd8, 0x80, 0x7c, 0xbb, 0xdd,
	0x10, 0x9e, 0x2f, 0x74, 0xe1, 0xdf, 0x15, 0xd8, 0xfb, 0xba, 0x7e, 0xfc, 0xf2, 0xf6, 0xcf, 0x41,
	0x03, 0xd5, 0x66, 0x41, 0xcc, 0x2e, 0xc2, 0xd4, 0x0d, 0xab, 0x73, 0x37, 0x8c, 0x61, 0x93, 0x5c,
	0x73, 0xf1, 0x32, 0x3a, 0x23, 0x66, 0x39, 0x44, 0xcf, 0x96, 0xd5, 0xc3, 0x5c, 0x6b, 0x9d, 0x5c,
	0xf3, 0x26, 0x09, 0x2f, 0x45, 0x09, 0x3f, 0x80, 0xad, 0x39, 0x69, 0x08, 0x41, 0xd6, 0x26, 0x01,
	0x8f, 0x27, 0x90, 0x31, 0xde, 0x83, 0xe2, 0xc5, 0xe4, 0x55, 0x2d, 0x4e, 0xf8, 0xab, 0x02, 0xe8,
	0xd4, 0xf5, 0xbb, 0xef, 0x38, 0x56, 0x09, 0xf2, 0x3d, 0xea, 0x10, 0xc6, 0xe3, 0xc9, 0xe2, 0x0c,
	0xd5, 0xe0, 0x4e, 0xdf, 0x62, 0xfd, 0x8e, 0xe5, 0x3a, 0x7e, 0x40, 0x79, 0xff, 0x4a, 0x8e, 0x78,
	0xa7, 0xba, 0x21, 0x50, 0x1a, 0x16, 0xeb, 0x9f, 0xb8, 0x8e, 0xdf, 0xda, 0xec, 0xc7, 0x91, 0xfc,
	0x04, 0x1f, 0x41, 0x51, 0xc8, 0xb0, 0xf8, 0x28, 0x20, 0x68, 0x17, 0x8a, 0x2c, 0x49, 0x62, 0xc1,
	0xd3, 0xc2, 0xa3, 0x0b, 0x58, 0x4b, 0x50, 0xd0, 0x0e, 0x68, 0x97, 0x1e, 0x1b, 0x12, 0x5b, 0xfc,
	0xbb, 0xf7, 0x3a, 0xa2, 0xae, 0xbd, 0x87, 0x00, 0xf2, 0xed, 0xc6, 0x49, 0xb5, 0xfa, 0x5c, 0x53,
	0x92, 0xb8, 0xfe, 0xb1, 0x96, 0x89, 0xe3, 0xda, 0x8b, 0xe7, 0x9a, 0x1a, 0xc7, 0xf5, 0x67, 0x55,
	0x2d, 0x5b, 0xfd, 0x13, 0xa0, 0x10, 0x9b, 0x80, 0x3c, 0x38, 0x38, 0x27, 0x7c, 0xce, 0xdd, 0x93,
	0xb1, 0x45, 0x5d, 0xab, 0xeb, 0x26, 0x2f, 0xa0, 0x49, 0x42, 0x86, 0x4a, 0x95, 0x68, 0x49, 0x55,
	0x92, 0x25, 0x55, 0x39, 0x13, 0x4b, 0xca, 0xd8, 0x98, 0x71, 0x8b, 0xe1, 0xfd, 0x9f, 0xfe, 0xf8,
	0xeb, 0xb7, 0x8c, 0x8e, 0x4a, 0xe6, 0xb8, 0x66, 0x32, 0xea, 0x98, 0xd7, 0xf5, 0xe3, 0x97, 0x4f,
	0xc5, 0xf5, 0x98, 0x62, 0xe9, 0x20, 0x02, 0x3b, 0x09, 0xdf, 0xc9, 0xec, 0x7d, 0xce, 0x7a, 0x6e,
	0x6c, 0x8b, 0x64, 0x4e, 0x13, 0x7e, 0x2c, 0x91, 0x1f, 0xa0, 0x8f, 0x96, 0x23, 0x9b, 0x3f, 0x4c,
	0xf7, 0xe0, 0x8f, 0xe8, 0x17, 0x05, 0xb6, 0x2f, 0x7c, 0x36, 0x3f, 0x18, 0xfa, 0x70, 0x09, 0x72,
	0xfa, 0x3d, 0x2c, 0x27, 0xff, 0x44, 0x92, 0x3f, 0xc3, 0x4f, 0x56, 0x91, 0x27, 0x4f, 0xa8, 0x32,
	0xa3, 0xe2, 0x95, 0xf2, 0x08, 0x8d, 0xe0, 0xe8, 0x9c, 0xf0, 0x4b, 0x46, 0x82, 0xf4, 0xe2, 0xb8,
	0x85, 0xc5, 0x58, 0x6a, 0xd9, 0x45, 0x46, 0xa2, 0x85, 0xb1, 0xfe, 0xd3, 0x11, 0x23, 0xc1, 0x8c,
	0xcd, 0x03, 0xb8, 0xbf, 0x94, 0x76, 0xca, 0x96, 0x76, 0x1c, 0xe2, 0xd5, 0xd6, 0x24, 0x21, 0x36,
	0x25, 0xfe, 0x11, 0x7a, 0xb8, 0x1a, 0x3f, 0x6d, 0xf6, 0xcf, 0x0a, 0x94, 0x84, 0xd9, 0x8b, 0x74,
	0xa8, 0xfc, 0xb6, 0x95, 0x99, 0x62, 0xfe, 0x54, 0x32, 0xd7, 0xf1, 0xf1, 0x4d, 0xcc, 0x37, 0x3b,
	0xdd, 0xf0, 0x19, 0xff, 0x7f, 0x9d, 0xee, 0xfb, 0x8c, 0x2f, 0x38, 0xbd, 0x48, 0xfb, 0xce, 0x4e,
	0xa7, 0xf1, 0x97, 0x3b, 0xbd, 0x48, 0xf7, 0x5f, 0x38, 0x3d, 0xcf, 0xbc, 0xca, 0xe9, 0x6f, 0xe1,
	0xde, 0x39, 0xe1, 0x62, 0x95, 0xde, 0xc2, 0xdb, 0x0f, 0xa4, 0x82, 0x6d, 0x74, 0x37, 0x51, 0xd0,
	0x75, 0xfd, 0x6e, 0x64, 0xe9, 0x57, 0x70, 0x37, 0xc6, 0x5f, 0x65, 0xe2, 0xa6, 0x48, 0x26, 0xbb,
	0x1e, 0x1f, 0x48, 0xac, 0x32, 0xda, 0x5f, 0xc0, 0x4a, 0xdb, 0x47, 0x61, 0x43, 0xb8, 0x27, 0x50,
	0x05, 0x3a, 0x2a, 0x09, 0x98, 0xc5, 0x9f, 0x84, 0x08, 0x7e, 0xb2, 0x9f, 0x71, 0x55, 0xc2, 0x3f,
	0xc1, 0x0f, 0x97, 0xc0, 0xaf, 0xf0, 0xe8, 0xb4, 0xf0, 0x4d, 0x2e, 0x1a, 0x3f, 0x2f, 0xff, 0xd4,
	0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x2b, 0x27, 0x53, 0xae, 0x11, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SigningClient is the client API for Signing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SigningClient interface {
	// GetX509CertificateAvailableSigningKeys returns all available keys that can sign X509 certificates.
	GetX509CertificateAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error)
	// GetX509CACertificate returns the CA X509 certificate self-signed by the specified key.
	GetX509CACertificate(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*X509Certificate, error)
	// PostX509Certificate signs the given CSR using the specified key and returns a PEM encoded X509 certificate.
	PostX509Certificate(ctx context.Context, in *X509CertificateSigningRequest, opts ...grpc.CallOption) (*X509Certificate, error)
	// GetUserSSHCertificateAvailableSigningKeys returns all available keys that can sign user SSH certificates.
	GetUserSSHCertificateAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error)
	// GetUserSSHCertificateSigningKey returns the public signing key of the
	// specified key that signs the user ssh certificate.
	GetUserSSHCertificateSigningKey(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*SSHKey, error)
	// PostUserSSHCertificate signs the SSH user certificate given request fields using the specified key.
	PostUserSSHCertificate(ctx context.Context, in *SSHCertificateSigningRequest, opts ...grpc.CallOption) (*SSHKey, error)
	// GetHostSSHCertificateAvailableSigningKeys returns all available keys that can sign host SSH certificates.
	GetHostSSHCertificateAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error)
	// GetHostSSHCertificateSigningKey returns the public signing key of the
	// specified key that signs the host ssh certificate.
	GetHostSSHCertificateSigningKey(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*SSHKey, error)
	// PostHostSSHCertificate signs the SSH host certificate given request fields using the specified key.
	PostHostSSHCertificate(ctx context.Context, in *SSHCertificateSigningRequest, opts ...grpc.CallOption) (*SSHKey, error)
	// GetBlobAvailableSigningKeys returns all available keys that can sign
	GetBlobAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error)
	// GetBlobSigningKey returns the public signing key of the
	// specified key that signs the user's data.
	GetBlobSigningKey(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*PublicKey, error)
	// PostSignBlob signs the digest using the specified key.
	PostSignBlob(ctx context.Context, in *BlobSigningRequest, opts ...grpc.CallOption) (*Signature, error)
}

type signingClient struct {
	cc *grpc.ClientConn
}

func NewSigningClient(cc *grpc.ClientConn) SigningClient {
	return &signingClient{cc}
}

func (c *signingClient) GetX509CertificateAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error) {
	out := new(KeyMetas)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetX509CertificateAvailableSigningKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) GetX509CACertificate(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*X509Certificate, error) {
	out := new(X509Certificate)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetX509CACertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) PostX509Certificate(ctx context.Context, in *X509CertificateSigningRequest, opts ...grpc.CallOption) (*X509Certificate, error) {
	out := new(X509Certificate)
	err := c.cc.Invoke(ctx, "/v3.Signing/PostX509Certificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) GetUserSSHCertificateAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error) {
	out := new(KeyMetas)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetUserSSHCertificateAvailableSigningKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) GetUserSSHCertificateSigningKey(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*SSHKey, error) {
	out := new(SSHKey)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetUserSSHCertificateSigningKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) PostUserSSHCertificate(ctx context.Context, in *SSHCertificateSigningRequest, opts ...grpc.CallOption) (*SSHKey, error) {
	out := new(SSHKey)
	err := c.cc.Invoke(ctx, "/v3.Signing/PostUserSSHCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) GetHostSSHCertificateAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error) {
	out := new(KeyMetas)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetHostSSHCertificateAvailableSigningKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) GetHostSSHCertificateSigningKey(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*SSHKey, error) {
	out := new(SSHKey)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetHostSSHCertificateSigningKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) PostHostSSHCertificate(ctx context.Context, in *SSHCertificateSigningRequest, opts ...grpc.CallOption) (*SSHKey, error) {
	out := new(SSHKey)
	err := c.cc.Invoke(ctx, "/v3.Signing/PostHostSSHCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) GetBlobAvailableSigningKeys(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*KeyMetas, error) {
	out := new(KeyMetas)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetBlobAvailableSigningKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) GetBlobSigningKey(ctx context.Context, in *KeyMeta, opts ...grpc.CallOption) (*PublicKey, error) {
	out := new(PublicKey)
	err := c.cc.Invoke(ctx, "/v3.Signing/GetBlobSigningKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signingClient) PostSignBlob(ctx context.Context, in *BlobSigningRequest, opts ...grpc.CallOption) (*Signature, error) {
	out := new(Signature)
	err := c.cc.Invoke(ctx, "/v3.Signing/PostSignBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SigningServer is the server API for Signing service.
type SigningServer interface {
	// GetX509CertificateAvailableSigningKeys returns all available keys that can sign X509 certificates.
	GetX509CertificateAvailableSigningKeys(context.Context, *empty.Empty) (*KeyMetas, error)
	// GetX509CACertificate returns the CA X509 certificate self-signed by the specified key.
	GetX509CACertificate(context.Context, *KeyMeta) (*X509Certificate, error)
	// PostX509Certificate signs the given CSR using the specified key and returns a PEM encoded X509 certificate.
	PostX509Certificate(context.Context, *X509CertificateSigningRequest) (*X509Certificate, error)
	// GetUserSSHCertificateAvailableSigningKeys returns all available keys that can sign user SSH certificates.
	GetUserSSHCertificateAvailableSigningKeys(context.Context, *empty.Empty) (*KeyMetas, error)
	// GetUserSSHCertificateSigningKey returns the public signing key of the
	// specified key that signs the user ssh certificate.
	GetUserSSHCertificateSigningKey(context.Context, *KeyMeta) (*SSHKey, error)
	// PostUserSSHCertificate signs the SSH user certificate given request fields using the specified key.
	PostUserSSHCertificate(context.Context, *SSHCertificateSigningRequest) (*SSHKey, error)
	// GetHostSSHCertificateAvailableSigningKeys returns all available keys that can sign host SSH certificates.
	GetHostSSHCertificateAvailableSigningKeys(context.Context, *empty.Empty) (*KeyMetas, error)
	// GetHostSSHCertificateSigningKey returns the public signing key of the
	// specified key that signs the host ssh certificate.
	GetHostSSHCertificateSigningKey(context.Context, *KeyMeta) (*SSHKey, error)
	// PostHostSSHCertificate signs the SSH host certificate given request fields using the specified key.
	PostHostSSHCertificate(context.Context, *SSHCertificateSigningRequest) (*SSHKey, error)
	// GetBlobAvailableSigningKeys returns all available keys that can sign
	GetBlobAvailableSigningKeys(context.Context, *empty.Empty) (*KeyMetas, error)
	// GetBlobSigningKey returns the public signing key of the
	// specified key that signs the user's data.
	GetBlobSigningKey(context.Context, *KeyMeta) (*PublicKey, error)
	// PostSignBlob signs the digest using the specified key.
	PostSignBlob(context.Context, *BlobSigningRequest) (*Signature, error)
}

// UnimplementedSigningServer can be embedded to have forward compatible implementations.
type UnimplementedSigningServer struct {
}

func (*UnimplementedSigningServer) GetX509CertificateAvailableSigningKeys(ctx context.Context, req *empty.Empty) (*KeyMetas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetX509CertificateAvailableSigningKeys not implemented")
}
func (*UnimplementedSigningServer) GetX509CACertificate(ctx context.Context, req *KeyMeta) (*X509Certificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetX509CACertificate not implemented")
}
func (*UnimplementedSigningServer) PostX509Certificate(ctx context.Context, req *X509CertificateSigningRequest) (*X509Certificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostX509Certificate not implemented")
}
func (*UnimplementedSigningServer) GetUserSSHCertificateAvailableSigningKeys(ctx context.Context, req *empty.Empty) (*KeyMetas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserSSHCertificateAvailableSigningKeys not implemented")
}
func (*UnimplementedSigningServer) GetUserSSHCertificateSigningKey(ctx context.Context, req *KeyMeta) (*SSHKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserSSHCertificateSigningKey not implemented")
}
func (*UnimplementedSigningServer) PostUserSSHCertificate(ctx context.Context, req *SSHCertificateSigningRequest) (*SSHKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostUserSSHCertificate not implemented")
}
func (*UnimplementedSigningServer) GetHostSSHCertificateAvailableSigningKeys(ctx context.Context, req *empty.Empty) (*KeyMetas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostSSHCertificateAvailableSigningKeys not implemented")
}
func (*UnimplementedSigningServer) GetHostSSHCertificateSigningKey(ctx context.Context, req *KeyMeta) (*SSHKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostSSHCertificateSigningKey not implemented")
}
func (*UnimplementedSigningServer) PostHostSSHCertificate(ctx context.Context, req *SSHCertificateSigningRequest) (*SSHKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostHostSSHCertificate not implemented")
}
func (*UnimplementedSigningServer) GetBlobAvailableSigningKeys(ctx context.Context, req *empty.Empty) (*KeyMetas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlobAvailableSigningKeys not implemented")
}
func (*UnimplementedSigningServer) GetBlobSigningKey(ctx context.Context, req *KeyMeta) (*PublicKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlobSigningKey not implemented")
}
func (*UnimplementedSigningServer) PostSignBlob(ctx context.Context, req *BlobSigningRequest) (*Signature, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSignBlob not implemented")
}

func RegisterSigningServer(s *grpc.Server, srv SigningServer) {
	s.RegisterService(&_Signing_serviceDesc, srv)
}

func _Signing_GetX509CertificateAvailableSigningKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetX509CertificateAvailableSigningKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetX509CertificateAvailableSigningKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetX509CertificateAvailableSigningKeys(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_GetX509CACertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetX509CACertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetX509CACertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetX509CACertificate(ctx, req.(*KeyMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_PostX509Certificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(X509CertificateSigningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).PostX509Certificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/PostX509Certificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).PostX509Certificate(ctx, req.(*X509CertificateSigningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_GetUserSSHCertificateAvailableSigningKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetUserSSHCertificateAvailableSigningKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetUserSSHCertificateAvailableSigningKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetUserSSHCertificateAvailableSigningKeys(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_GetUserSSHCertificateSigningKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetUserSSHCertificateSigningKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetUserSSHCertificateSigningKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetUserSSHCertificateSigningKey(ctx, req.(*KeyMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_PostUserSSHCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SSHCertificateSigningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).PostUserSSHCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/PostUserSSHCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).PostUserSSHCertificate(ctx, req.(*SSHCertificateSigningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_GetHostSSHCertificateAvailableSigningKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetHostSSHCertificateAvailableSigningKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetHostSSHCertificateAvailableSigningKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetHostSSHCertificateAvailableSigningKeys(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_GetHostSSHCertificateSigningKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetHostSSHCertificateSigningKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetHostSSHCertificateSigningKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetHostSSHCertificateSigningKey(ctx, req.(*KeyMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_PostHostSSHCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SSHCertificateSigningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).PostHostSSHCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/PostHostSSHCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).PostHostSSHCertificate(ctx, req.(*SSHCertificateSigningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_GetBlobAvailableSigningKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetBlobAvailableSigningKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetBlobAvailableSigningKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetBlobAvailableSigningKeys(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_GetBlobSigningKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).GetBlobSigningKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/GetBlobSigningKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).GetBlobSigningKey(ctx, req.(*KeyMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signing_PostSignBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobSigningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SigningServer).PostSignBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v3.Signing/PostSignBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SigningServer).PostSignBlob(ctx, req.(*BlobSigningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Signing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v3.Signing",
	HandlerType: (*SigningServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetX509CertificateAvailableSigningKeys",
			Handler:    _Signing_GetX509CertificateAvailableSigningKeys_Handler,
		},
		{
			MethodName: "GetX509CACertificate",
			Handler:    _Signing_GetX509CACertificate_Handler,
		},
		{
			MethodName: "PostX509Certificate",
			Handler:    _Signing_PostX509Certificate_Handler,
		},
		{
			MethodName: "GetUserSSHCertificateAvailableSigningKeys",
			Handler:    _Signing_GetUserSSHCertificateAvailableSigningKeys_Handler,
		},
		{
			MethodName: "GetUserSSHCertificateSigningKey",
			Handler:    _Signing_GetUserSSHCertificateSigningKey_Handler,
		},
		{
			MethodName: "PostUserSSHCertificate",
			Handler:    _Signing_PostUserSSHCertificate_Handler,
		},
		{
			MethodName: "GetHostSSHCertificateAvailableSigningKeys",
			Handler:    _Signing_GetHostSSHCertificateAvailableSigningKeys_Handler,
		},
		{
			MethodName: "GetHostSSHCertificateSigningKey",
			Handler:    _Signing_GetHostSSHCertificateSigningKey_Handler,
		},
		{
			MethodName: "PostHostSSHCertificate",
			Handler:    _Signing_PostHostSSHCertificate_Handler,
		},
		{
			MethodName: "GetBlobAvailableSigningKeys",
			Handler:    _Signing_GetBlobAvailableSigningKeys_Handler,
		},
		{
			MethodName: "GetBlobSigningKey",
			Handler:    _Signing_GetBlobSigningKey_Handler,
		},
		{
			MethodName: "PostSignBlob",
			Handler:    _Signing_PostSignBlob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sign.proto",
}
